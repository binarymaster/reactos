/*
 * PROJECT:         Xbox HAL
 * LICENSE:         GPL-2.0-or-later (https://spdx.org/licenses/GPL-2.0-or-later)
 * PURPOSE:         Xbox Plug-n-Play support
 * COPYRIGHT:       Copyright 2020 Stanislav Motylkov (x86corez@gmail.com)
 */

/* INCLUDES ******************************************************************/

#include "halxbox.h"

#define NDEBUG
#include <debug.h>

#include <drivers/xbox/superio.h>

typedef enum _EXTENSION_TYPE
{
    PdoExtensionType = 0xC0,
    FdoExtensionType
} EXTENSION_TYPE;

typedef enum _PDO_TYPE
{
    CpuPdo = 0x20,
    PicPdo,
    DmaPdo,
    CmosPdo,
    TimerPdo,
    SpeakerPdo,
    LpcPdo,
    LpcFddPdo,
    LpcParPdo,
    LpcSer1Pdo,
    LpcSer2Pdo,
    LpcKbdPdo,
    LpcMouPdo,
    LpcJoyPdo,
    LpcMpuPdo
} PDO_TYPE;

typedef struct _FDO_EXTENSION
{
    EXTENSION_TYPE ExtensionType;
    struct _PDO_EXTENSION* ChildPdoList;
    PDEVICE_OBJECT PhysicalDeviceObject;
    PDEVICE_OBJECT FunctionalDeviceObject;
    PDEVICE_OBJECT AttachedDeviceObject;
} FDO_EXTENSION, *PFDO_EXTENSION;

typedef struct _PDO_EXTENSION
{
    EXTENSION_TYPE ExtensionType;
    struct _PDO_EXTENSION* Next;
    PDEVICE_OBJECT PhysicalDeviceObject;
    PFDO_EXTENSION ParentFdoExtension;
    PDO_TYPE PdoType;
    PDESCRIPTION_HEADER WdTable;
    LONG InterfaceReferenceCount;
} PDO_EXTENSION, *PPDO_EXTENSION;

/* GLOBALS ********************************************************************/
static ULONG LpcBase = 0;

static ULONG FddBase = 0;
static ULONG FddIrq = 0;
static ULONG FddDma = 0;

static ULONG ParBase = 0;
static ULONG ParIrq = 0;
static ULONG ParDma = 0;

static ULONG Com1Base = 0;
static ULONG Com1Irq = 0;

static ULONG Com2Base = 0;
static ULONG Com2Irq = 0;

static ULONG KbdIrq = 0;
static ULONG MouIrq = 0;

static ULONG JoyBase = 0;

//static ULONG GpioBase = 0;

static ULONG MpuBase = 0;
static ULONG MpuIrq = 0;

/* PRIVATE FUNCTIONS *********************************************************/

NTSTATUS
NTAPI
HaliXboxCreatePdo(
    IN PDRIVER_OBJECT DriverObject,
    IN PVOID Context,
    IN OUT PPDO_EXTENSION * PdoExtension,
    IN DEVICE_TYPE DeviceType,
    IN PDO_TYPE PdoType,
    IN OUT PULONG Count,
    IN BOOLEAN Root)
{
    PFDO_EXTENSION FdoExtension = Context;
    PDEVICE_OBJECT PdoDeviceObject;
    NTSTATUS Status;

    /* Create the PDO */
    Status = IoCreateDevice(DriverObject,
                            sizeof(PDO_EXTENSION),
                            NULL,
                            DeviceType,
                            FILE_AUTOGENERATED_DEVICE_NAME,
                            FALSE,
                            &PdoDeviceObject);

    if (!NT_SUCCESS(Status))
        return Status;

    if (!Root)
        (*PdoExtension)->Next = PdoDeviceObject->DeviceExtension;

    /* Setup the PDO device extension */
    if (Root)
       *PdoExtension = PdoDeviceObject->DeviceExtension;
    else
       *PdoExtension = (*PdoExtension)->Next;
    (*PdoExtension)->ExtensionType = PdoExtensionType;
    (*PdoExtension)->PhysicalDeviceObject = PdoDeviceObject;
    (*PdoExtension)->ParentFdoExtension = FdoExtension;
    (*PdoExtension)->PdoType = PdoType;
    (*PdoExtension)->Next = NULL;

    /* Initialization is finished */
    PdoDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
    (*Count)++;

    return STATUS_SUCCESS;
}

/* PUBLIC FUNCTIONS **********************************************************/

/*
 * @implemented
 */
VOID
NTAPI
HalpXboxReportDetectedDevices(
    IN PDRIVER_OBJECT DriverObject,
    IN PVOID Context,
    IN ULONG Count)
{
    PPDO_EXTENSION PdoExtension;
    PFDO_EXTENSION FdoExtension = Context;

    /* Detect physical non-PnP devices */
    LpcBase = LpcDetectSuperIO();
    if (LpcBase)
    {
        LpcEnterConfig();

        LpcWriteRegister(LPC_CONFIG_DEVICE_NUMBER, LPC_DEVICE_FDD);
        if (LpcReadRegister(LPC_CONFIG_DEVICE_ACTIVATE) == 1)
        {
            FddBase = LpcGetIoBase();
            FddIrq = LpcGetIrqPrimary();
            FddDma = LpcGetDmaChannel();
        }

        LpcWriteRegister(LPC_CONFIG_DEVICE_NUMBER, LPC_DEVICE_PARALLEL_PORT);
        if (LpcReadRegister(LPC_CONFIG_DEVICE_ACTIVATE) == 1)
        {
            ParBase = LpcGetIoBase();
            ParIrq = LpcGetIrqPrimary();
            ParIrq = LpcGetDmaChannel();
        }

        LpcWriteRegister(LPC_CONFIG_DEVICE_NUMBER, LPC_DEVICE_SERIAL_PORT_1);
        if (LpcReadRegister(LPC_CONFIG_DEVICE_ACTIVATE) == 1)
        {
            Com1Base = LpcGetIoBase();
            Com1Irq = LpcGetIrqPrimary();
        }

        LpcWriteRegister(LPC_CONFIG_DEVICE_NUMBER, LPC_DEVICE_SERIAL_PORT_2);
        if (LpcReadRegister(LPC_CONFIG_DEVICE_ACTIVATE) == 1)
        {
            Com2Base = LpcGetIoBase();
            Com2Irq = LpcGetIrqPrimary();
        }

        LpcWriteRegister(LPC_CONFIG_DEVICE_NUMBER, LPC_DEVICE_KEYBOARD);
        if (LpcReadRegister(LPC_CONFIG_DEVICE_ACTIVATE) == 1)
        {
            KbdIrq = LpcGetIrqPrimary();
            MouIrq = LpcGetIrqSecondary();
        }

        LpcWriteRegister(LPC_CONFIG_DEVICE_NUMBER, LPC_DEVICE_GAME_PORT);
        if (LpcReadRegister(LPC_CONFIG_DEVICE_ACTIVATE) == 1)
        {
            JoyBase = LpcGetIoBase();
        }

        /*LpcWriteRegister(LPC_CONFIG_DEVICE_NUMBER, LPC_DEVICE_PME);
        if (LpcReadRegister(LPC_CONFIG_DEVICE_ACTIVATE) == 1)
        {
            GpioBase = LpcGetIoBase();
        }*/

        LpcWriteRegister(LPC_CONFIG_DEVICE_NUMBER, LPC_DEVICE_MPU_401);
        if (LpcReadRegister(LPC_CONFIG_DEVICE_ACTIVATE) == 1)
        {
            MpuBase = LpcGetIoBaseMPU();
            MpuIrq = LpcGetIrqPrimary();
        }

        LpcExitConfig();
    }

    /* Go to the last PDO in the list */
    for (PdoExtension = FdoExtension->ChildPdoList;
         PdoExtension->Next != NULL && PdoExtension->Next != FdoExtension->ChildPdoList;
         PdoExtension = PdoExtension->Next);

    Count = 0;

    if (KeGetCurrentPrcb()->CpuID)
    {
        /* Create the CPU PDO */
        HaliXboxCreatePdo(DriverObject,
                          Context,
                          &PdoExtension,
                          FILE_DEVICE_ACPI,
                          CpuPdo,
                          &Count,
                          FALSE);
    }

    /* Create the PIC PDO */
    HaliXboxCreatePdo(DriverObject,
                      Context,
                      &PdoExtension,
                      FILE_DEVICE_ACPI,
                      PicPdo,
                      &Count,
                      FALSE);

    /* Create the DMA PDO */
    HaliXboxCreatePdo(DriverObject,
                      Context,
                      &PdoExtension,
                      FILE_DEVICE_ACPI,
                      DmaPdo,
                      &Count,
                      FALSE);

    /* Create the CMOS/RTC PDO */
    HaliXboxCreatePdo(DriverObject,
                      Context,
                      &PdoExtension,
                      FILE_DEVICE_ACPI,
                      CmosPdo,
                      &Count,
                      FALSE);

    /* Create the Timer PDO */
    HaliXboxCreatePdo(DriverObject,
                      Context,
                      &PdoExtension,
                      FILE_DEVICE_ACPI,
                      TimerPdo,
                      &Count,
                      FALSE);

    /* Create the Speaker PDO */
    HaliXboxCreatePdo(DriverObject,
                      Context,
                      &PdoExtension,
                      FILE_DEVICE_ACPI,
                      SpeakerPdo,
                      &Count,
                      FALSE);

    if (LpcBase)
    {
        /* Create the Lpc PDO */
        HaliXboxCreatePdo(DriverObject,
                          Context,
                          &PdoExtension,
                          FILE_DEVICE_BUS_EXTENDER,
                          LpcPdo,
                          &Count,
                          FALSE);
    }

    if (PdoExtension->PdoType == LpcPdo)
    {
        if (FddBase)
        {
            /* Create the Floppy PDO */
            HaliXboxCreatePdo(DriverObject,
                              Context,
                              &PdoExtension,
                              FILE_DEVICE_ACPI,
                              LpcFddPdo,
                              &Count,
                              FALSE);
        }

        if (ParBase)
        {
            /* Create the Parallel LPT1 PDO */
            HaliXboxCreatePdo(DriverObject,
                              Context,
                              &PdoExtension,
                              FILE_DEVICE_ACPI,
                              LpcParPdo,
                              &Count,
                              FALSE);
        }

        if (Com1Base)
        {
            /* Create the Serial COM1 PDO */
            HaliXboxCreatePdo(DriverObject,
                              Context,
                              &PdoExtension,
                              FILE_DEVICE_ACPI,
                              LpcSer1Pdo,
                              &Count,
                              FALSE);
        }

        if (Com2Base)
        {
            /* Create the Serial COM2 PDO */
            HaliXboxCreatePdo(DriverObject,
                              Context,
                              &PdoExtension,
                              FILE_DEVICE_ACPI,
                              LpcSer2Pdo,
                              &Count,
                              FALSE);
        }

        if (KbdIrq)
        {
            /* Create the Keyboard PDO */
            HaliXboxCreatePdo(DriverObject,
                              Context,
                              &PdoExtension,
                              FILE_DEVICE_ACPI,
                              LpcKbdPdo,
                              &Count,
                              FALSE);
        }

        if (MouIrq)
        {
            /* Create the Mouse PDO */
            HaliXboxCreatePdo(DriverObject,
                              Context,
                              &PdoExtension,
                              FILE_DEVICE_ACPI,
                              LpcMouPdo,
                              &Count,
                              FALSE);
        }

        if (JoyBase)
        {
            /* Create the Game Port PDO */
            HaliXboxCreatePdo(DriverObject,
                              Context,
                              &PdoExtension,
                              FILE_DEVICE_ACPI,
                              LpcJoyPdo,
                              &Count,
                              FALSE);
        }

        if (MpuBase)
        {
            /* Create the MPU-401 PDO */
            HaliXboxCreatePdo(DriverObject,
                              Context,
                              &PdoExtension,
                              FILE_DEVICE_ACPI,
                              LpcMpuPdo,
                              &Count,
                              FALSE);
        }
    }
}

NTSTATUS
NTAPI
HalpXboxQueryResources(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PCM_RESOURCE_LIST *Resources)
{
    PPDO_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS Status;
    PCM_RESOURCE_LIST ResourceList;

    if (DeviceExtension->PdoType == PicPdo)
    {
        PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialDesc;

        /* Allocate the resource list */
        ResourceList = ExAllocatePoolWithTag(PagedPool,
                                             sizeof(CM_RESOURCE_LIST) +
                                             sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR),
                                             TAG_HAL_XBOX);
        if (!ResourceList)
        {
            /* Fail, no memory */
            Status = STATUS_INSUFFICIENT_RESOURCES;
            return Status;
        }

        /* Initialize it */
        RtlZeroMemory(ResourceList, sizeof(CM_RESOURCE_LIST));
        ResourceList->Count = 1;

        /* Setup the list fields */
        ResourceList->List[0].BusNumber = 0;
        ResourceList->List[0].InterfaceType = Isa;
        ResourceList->List[0].PartialResourceList.Version = 1;
        ResourceList->List[0].PartialResourceList.Revision = 1;
        ResourceList->List[0].PartialResourceList.Count = 2;

        PartialDesc = ResourceList->List[0].PartialResourceList.PartialDescriptors;
        PartialDesc->Type = CmResourceTypePort;
        PartialDesc->ShareDisposition = CmResourceShareDeviceExclusive;
        PartialDesc->Flags = CM_RESOURCE_PORT_IO;
        PartialDesc->u.Port.Start.LowPart = PIC1_CONTROL_PORT;
        PartialDesc->u.Port.Start.HighPart = 0;
        PartialDesc->u.Port.Length = 2;

        PartialDesc++;
        PartialDesc->Type = CmResourceTypePort;
        PartialDesc->ShareDisposition = CmResourceShareDeviceExclusive;
        PartialDesc->Flags = CM_RESOURCE_PORT_IO;
        PartialDesc->u.Port.Start.LowPart = PIC2_CONTROL_PORT;
        PartialDesc->u.Port.Start.HighPart = 0;
        PartialDesc->u.Port.Length = 2;

        /* Return resources and success */
        *Resources = ResourceList;

        return STATUS_SUCCESS;
    }
    else if (DeviceExtension->PdoType == DmaPdo)
    {
        PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialDesc;

        /* Allocate the resource list */
        ResourceList = ExAllocatePoolWithTag(PagedPool,
                                             sizeof(CM_RESOURCE_LIST) +
                                             3 * sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR),
                                             TAG_HAL_XBOX);
        if (!ResourceList)
        {
            /* Fail, no memory */
            Status = STATUS_INSUFFICIENT_RESOURCES;
            return Status;
        }

        /* Initialize it */
        RtlZeroMemory(ResourceList, sizeof(CM_RESOURCE_LIST));
        ResourceList->Count = 1;

        /* Setup the list fields */
        ResourceList->List[0].BusNumber = 0;
        ResourceList->List[0].InterfaceType = Isa;
        ResourceList->List[0].PartialResourceList.Version = 1;
        ResourceList->List[0].PartialResourceList.Revision = 1;
        ResourceList->List[0].PartialResourceList.Count = 4;

        PartialDesc = ResourceList->List[0].PartialResourceList.PartialDescriptors;
        PartialDesc->Type = CmResourceTypePort;
        PartialDesc->ShareDisposition = CmResourceShareDeviceExclusive;
        PartialDesc->Flags = CM_RESOURCE_PORT_IO;
        PartialDesc->u.Port.Start.LowPart = 0x00; /* Master DMA */
        PartialDesc->u.Port.Start.HighPart = 0;
        PartialDesc->u.Port.Length = 16;

        PartialDesc++;
        PartialDesc->Type = CmResourceTypePort;
        PartialDesc->ShareDisposition = CmResourceShareDeviceExclusive;
        PartialDesc->Flags = CM_RESOURCE_PORT_IO;
        PartialDesc->u.Port.Start.LowPart = 0x80; /* Page registers */
        PartialDesc->u.Port.Start.HighPart = 0;
        PartialDesc->u.Port.Length = 16;

        PartialDesc++;
        PartialDesc->Type = CmResourceTypePort;
        PartialDesc->ShareDisposition = CmResourceShareDeviceExclusive;
        PartialDesc->Flags = CM_RESOURCE_PORT_IO;
        PartialDesc->u.Port.Start.LowPart = 0xC0; /* Slave DMA */
        PartialDesc->u.Port.Start.HighPart = 0;
        PartialDesc->u.Port.Length = 32;

        PartialDesc++;
        PartialDesc->Type = CmResourceTypeDma;
        PartialDesc->ShareDisposition = CmResourceShareUndetermined;
        PartialDesc->Flags = 0;
        PartialDesc->u.Dma.Channel = 4;
        PartialDesc->u.Dma.Port = 0;

        /* Return resources and success */
        *Resources = ResourceList;

        return STATUS_SUCCESS;
    }
    else if (DeviceExtension->PdoType == CmosPdo)
    {
        PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialDesc;

        /* Allocate the resource list */
        ResourceList = ExAllocatePoolWithTag(PagedPool,
                                             sizeof(CM_RESOURCE_LIST) +
                                             2 * sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR),
                                             TAG_HAL_XBOX);
        if (!ResourceList)
        {
            /* Fail, no memory */
            Status = STATUS_INSUFFICIENT_RESOURCES;
            return Status;
        }

        /* Initialize it */
        RtlZeroMemory(ResourceList, sizeof(CM_RESOURCE_LIST));
        ResourceList->Count = 1;

        /* Setup the list fields */
        ResourceList->List[0].BusNumber = 0;
        ResourceList->List[0].InterfaceType = Isa;
        ResourceList->List[0].PartialResourceList.Version = 1;
        ResourceList->List[0].PartialResourceList.Revision = 1;
        ResourceList->List[0].PartialResourceList.Count = 3;

        PartialDesc = ResourceList->List[0].PartialResourceList.PartialDescriptors;
        PartialDesc->Type = CmResourceTypePort;
        PartialDesc->ShareDisposition = CmResourceShareDeviceExclusive;
        PartialDesc->Flags = CM_RESOURCE_PORT_IO;
        PartialDesc->u.Port.Start.LowPart = (ULONG)CMOS_CONTROL_PORT;
        PartialDesc->u.Port.Start.HighPart = 0;
        PartialDesc->u.Port.Length = 2;

        PartialDesc++;
        PartialDesc->Type = CmResourceTypePort;
        PartialDesc->ShareDisposition = CmResourceShareDeviceExclusive;
        PartialDesc->Flags = CM_RESOURCE_PORT_IO;
        PartialDesc->u.Port.Start.LowPart = 0x72; /* RTC */
        PartialDesc->u.Port.Start.HighPart = 0;
        PartialDesc->u.Port.Length = 6;

        PartialDesc++;
        PartialDesc->Type = CmResourceTypeInterrupt;
        PartialDesc->ShareDisposition = CmResourceShareUndetermined;
        PartialDesc->Flags = CM_RESOURCE_INTERRUPT_LATCHED;
        PartialDesc->u.Interrupt.Vector = PIC_RTC_IRQ;
        PartialDesc->u.Interrupt.Level = PIC_RTC_IRQ;
        PartialDesc->u.Interrupt.Affinity = 0xFFFFFFFF;

        /* Return resources and success */
        *Resources = ResourceList;

        return STATUS_SUCCESS;
    }
    else if (DeviceExtension->PdoType == TimerPdo)
    {
        PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialDesc;

        /* Allocate the resource list */
        ResourceList = ExAllocatePoolWithTag(PagedPool,
                                             sizeof(CM_RESOURCE_LIST) +
                                             sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR),
                                             TAG_HAL_XBOX);
        if (!ResourceList)
        {
            /* Fail, no memory */
            Status = STATUS_INSUFFICIENT_RESOURCES;
            return Status;
        }

        /* Initialize it */
        RtlZeroMemory(ResourceList, sizeof(CM_RESOURCE_LIST));
        ResourceList->Count = 1;

        /* Setup the list fields */
        ResourceList->List[0].BusNumber = 0;
        ResourceList->List[0].InterfaceType = Isa;
        ResourceList->List[0].PartialResourceList.Version = 1;
        ResourceList->List[0].PartialResourceList.Revision = 1;
        ResourceList->List[0].PartialResourceList.Count = 2;

        PartialDesc = ResourceList->List[0].PartialResourceList.PartialDescriptors;
        PartialDesc->Type = CmResourceTypePort;
        PartialDesc->ShareDisposition = CmResourceShareDeviceExclusive;
        PartialDesc->Flags = CM_RESOURCE_PORT_IO;
        PartialDesc->u.Port.Start.LowPart = TIMER_CHANNEL0_DATA_PORT;
        PartialDesc->u.Port.Start.HighPart = 0;
        PartialDesc->u.Port.Length = 4;

        PartialDesc++;
        PartialDesc->Type = CmResourceTypeInterrupt;
        PartialDesc->ShareDisposition = CmResourceShareUndetermined;
        PartialDesc->Flags = CM_RESOURCE_INTERRUPT_LATCHED;
        PartialDesc->u.Interrupt.Vector = PIC_TIMER_IRQ;
        PartialDesc->u.Interrupt.Level = PIC_TIMER_IRQ;
        PartialDesc->u.Interrupt.Affinity = 0xFFFFFFFF;

        /* Return resources and success */
        *Resources = ResourceList;

        return STATUS_SUCCESS;
    }
    else if (DeviceExtension->PdoType == SpeakerPdo)
    {
        PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialDesc;

        /* Allocate the resource list */
        ResourceList = ExAllocatePoolWithTag(PagedPool,
                                             sizeof(CM_RESOURCE_LIST),
                                             TAG_HAL_XBOX);
        if (!ResourceList)
        {
            /* Fail, no memory */
            Status = STATUS_INSUFFICIENT_RESOURCES;
            return Status;
        }

        /* Initialize it */
        RtlZeroMemory(ResourceList, sizeof(CM_RESOURCE_LIST));
        ResourceList->Count = 1;

        /* Setup the list fields */
        ResourceList->List[0].BusNumber = 0;
        ResourceList->List[0].InterfaceType = Isa;
        ResourceList->List[0].PartialResourceList.Version = 1;
        ResourceList->List[0].PartialResourceList.Revision = 1;
        ResourceList->List[0].PartialResourceList.Count = 1;

        PartialDesc = ResourceList->List[0].PartialResourceList.PartialDescriptors;
        PartialDesc->Type = CmResourceTypePort;
        PartialDesc->ShareDisposition = CmResourceShareDeviceExclusive;
        PartialDesc->Flags = CM_RESOURCE_PORT_IO;
        PartialDesc->u.Port.Start.LowPart = SYSTEM_CONTROL_PORT_B;
        PartialDesc->u.Port.Start.HighPart = 0;
        PartialDesc->u.Port.Length = 1;

        /* Return resources and success */
        *Resources = ResourceList;

        return STATUS_SUCCESS;
    }
    else if (DeviceExtension->PdoType == LpcPdo)
    {
        PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialDesc;

        /* Allocate the resource list */
        ResourceList = ExAllocatePoolWithTag(PagedPool,
                                             sizeof(CM_RESOURCE_LIST),
                                             TAG_HAL_XBOX);
        if (!ResourceList)
        {
            /* Fail, no memory */
            Status = STATUS_INSUFFICIENT_RESOURCES;
            return Status;
        }

        /* Initialize it */
        RtlZeroMemory(ResourceList, sizeof(CM_RESOURCE_LIST));
        ResourceList->Count = 1;

        /* Setup the list fields */
        ResourceList->List[0].BusNumber = 0;
        ResourceList->List[0].InterfaceType = Isa;
        ResourceList->List[0].PartialResourceList.Version = 1;
        ResourceList->List[0].PartialResourceList.Revision = 1;
        ResourceList->List[0].PartialResourceList.Count = 1;

        PartialDesc = ResourceList->List[0].PartialResourceList.PartialDescriptors;
        PartialDesc->Type = CmResourceTypePort;
        PartialDesc->ShareDisposition = CmResourceShareDeviceExclusive;
        PartialDesc->Flags = CM_RESOURCE_PORT_IO;
        PartialDesc->u.Port.Start.LowPart = LpcBase;
        PartialDesc->u.Port.Start.HighPart = 0;
        PartialDesc->u.Port.Length = 2;

        /* Return resources and success */
        *Resources = ResourceList;

        return STATUS_SUCCESS;
    }
    else if (DeviceExtension->PdoType == LpcFddPdo)
    {
        PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialDesc;

        /* Allocate the resource list */
        ResourceList = ExAllocatePoolWithTag(PagedPool,
                                             sizeof(CM_RESOURCE_LIST) +
                                             2 * sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR),
                                             TAG_HAL_XBOX);
        if (!ResourceList)
        {
            /* Fail, no memory */
            Status = STATUS_INSUFFICIENT_RESOURCES;
            return Status;
        }

        /* Initialize it */
        RtlZeroMemory(ResourceList, sizeof(CM_RESOURCE_LIST));
        ResourceList->Count = 1;

        /* Setup the list fields */
        ResourceList->List[0].BusNumber = 0;
        ResourceList->List[0].InterfaceType = Isa;
        ResourceList->List[0].PartialResourceList.Version = 1;
        ResourceList->List[0].PartialResourceList.Revision = 1;
        ResourceList->List[0].PartialResourceList.Count = 3;

        PartialDesc = ResourceList->List[0].PartialResourceList.PartialDescriptors;
        PartialDesc->Type = CmResourceTypePort;
        PartialDesc->ShareDisposition = CmResourceShareDeviceExclusive;
        PartialDesc->Flags = CM_RESOURCE_PORT_IO;
        PartialDesc->u.Port.Start.LowPart = FddBase;
        PartialDesc->u.Port.Start.HighPart = 0;
        PartialDesc->u.Port.Length = 8;

        PartialDesc++;
        PartialDesc->Type = CmResourceTypeInterrupt;
        PartialDesc->ShareDisposition = CmResourceShareUndetermined;
        PartialDesc->Flags = CM_RESOURCE_INTERRUPT_LATCHED;
        PartialDesc->u.Interrupt.Vector = FddIrq;
        PartialDesc->u.Interrupt.Level = FddIrq;
        PartialDesc->u.Interrupt.Affinity = 0xFFFFFFFF;

        PartialDesc++;
        PartialDesc->Type = CmResourceTypeDma;
        PartialDesc->ShareDisposition = CmResourceShareUndetermined;
        PartialDesc->Flags = 0;
        PartialDesc->u.Dma.Channel = FddDma;
        PartialDesc->u.Dma.Port = 0;

        /* Return resources and success */
        *Resources = ResourceList;

        return STATUS_SUCCESS;
    }
    else if (DeviceExtension->PdoType == LpcParPdo)
    {
        PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialDesc;

        /* Allocate the resource list */
        ResourceList = ExAllocatePoolWithTag(PagedPool,
                                             sizeof(CM_RESOURCE_LIST) +
                                             2 * sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR),
                                             TAG_HAL_XBOX);
        if (!ResourceList)
        {
            /* Fail, no memory */
            Status = STATUS_INSUFFICIENT_RESOURCES;
            return Status;
        }

        /* Initialize it */
        RtlZeroMemory(ResourceList, sizeof(CM_RESOURCE_LIST));
        ResourceList->Count = 1;

        /* Setup the list fields */
        ResourceList->List[0].BusNumber = 0;
        ResourceList->List[0].InterfaceType = Isa;
        ResourceList->List[0].PartialResourceList.Version = 1;
        ResourceList->List[0].PartialResourceList.Revision = 1;
        ResourceList->List[0].PartialResourceList.Count = 3;

        PartialDesc = ResourceList->List[0].PartialResourceList.PartialDescriptors;
        PartialDesc->Type = CmResourceTypePort;
        PartialDesc->ShareDisposition = CmResourceShareDeviceExclusive;
        PartialDesc->Flags = CM_RESOURCE_PORT_IO;
        PartialDesc->u.Port.Start.LowPart = ParBase;
        PartialDesc->u.Port.Start.HighPart = 0;
        PartialDesc->u.Port.Length = 8;

        PartialDesc++;
        PartialDesc->Type = CmResourceTypeInterrupt;
        PartialDesc->ShareDisposition = CmResourceShareUndetermined;
        PartialDesc->Flags = CM_RESOURCE_INTERRUPT_LATCHED;
        PartialDesc->u.Interrupt.Vector = ParIrq;
        PartialDesc->u.Interrupt.Level = ParIrq;
        PartialDesc->u.Interrupt.Affinity = 0xFFFFFFFF;

        PartialDesc++;
        PartialDesc->Type = CmResourceTypeDma;
        PartialDesc->ShareDisposition = CmResourceShareUndetermined;
        PartialDesc->Flags = 0;
        PartialDesc->u.Dma.Channel = ParDma;
        PartialDesc->u.Dma.Port = 0;

        /* Return resources and success */
        *Resources = ResourceList;

        return STATUS_SUCCESS;
    }
    else if (DeviceExtension->PdoType == LpcSer1Pdo)
    {
        PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialDesc;

        /* Allocate the resource list */
        ResourceList = ExAllocatePoolWithTag(PagedPool,
                                             sizeof(CM_RESOURCE_LIST) +
                                             sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR),
                                             TAG_HAL_XBOX);
        if (!ResourceList)
        {
            /* Fail, no memory */
            Status = STATUS_INSUFFICIENT_RESOURCES;
            return Status;
        }

        /* Initialize it */
        RtlZeroMemory(ResourceList, sizeof(CM_RESOURCE_LIST));
        ResourceList->Count = 1;

        /* Setup the list fields */
        ResourceList->List[0].BusNumber = 0;
        ResourceList->List[0].InterfaceType = Isa;
        ResourceList->List[0].PartialResourceList.Version = 1;
        ResourceList->List[0].PartialResourceList.Revision = 1;
        ResourceList->List[0].PartialResourceList.Count = 2;

        PartialDesc = ResourceList->List[0].PartialResourceList.PartialDescriptors;
        PartialDesc->Type = CmResourceTypePort;
        PartialDesc->ShareDisposition = CmResourceShareDeviceExclusive;
        PartialDesc->Flags = CM_RESOURCE_PORT_IO;
        PartialDesc->u.Port.Start.LowPart = Com1Base;
        PartialDesc->u.Port.Start.HighPart = 0;
        PartialDesc->u.Port.Length = 8;

        PartialDesc++;
        PartialDesc->Type = CmResourceTypeInterrupt;
        PartialDesc->ShareDisposition = CmResourceShareUndetermined;
        PartialDesc->Flags = CM_RESOURCE_INTERRUPT_LATCHED;
        PartialDesc->u.Interrupt.Vector = Com1Irq;
        PartialDesc->u.Interrupt.Level = Com1Irq;
        PartialDesc->u.Interrupt.Affinity = 0xFFFFFFFF;

        /* Return resources and success */
        *Resources = ResourceList;

        return STATUS_SUCCESS;
    }
    else if (DeviceExtension->PdoType == LpcSer2Pdo)
    {
        PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialDesc;

        /* Allocate the resource list */
        ResourceList = ExAllocatePoolWithTag(PagedPool,
                                             sizeof(CM_RESOURCE_LIST) +
                                             sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR),
                                             TAG_HAL_XBOX);
        if (!ResourceList)
        {
            /* Fail, no memory */
            Status = STATUS_INSUFFICIENT_RESOURCES;
            return Status;
        }

        /* Initialize it */
        RtlZeroMemory(ResourceList, sizeof(CM_RESOURCE_LIST));
        ResourceList->Count = 1;

        /* Setup the list fields */
        ResourceList->List[0].BusNumber = 0;
        ResourceList->List[0].InterfaceType = Isa;
        ResourceList->List[0].PartialResourceList.Version = 1;
        ResourceList->List[0].PartialResourceList.Revision = 1;
        ResourceList->List[0].PartialResourceList.Count = 2;

        PartialDesc = ResourceList->List[0].PartialResourceList.PartialDescriptors;
        PartialDesc->Type = CmResourceTypePort;
        PartialDesc->ShareDisposition = CmResourceShareDeviceExclusive;
        PartialDesc->Flags = CM_RESOURCE_PORT_IO;
        PartialDesc->u.Port.Start.LowPart = Com2Base;
        PartialDesc->u.Port.Start.HighPart = 0;
        PartialDesc->u.Port.Length = 8;

        PartialDesc++;
        PartialDesc->Type = CmResourceTypeInterrupt;
        PartialDesc->ShareDisposition = CmResourceShareUndetermined;
        PartialDesc->Flags = CM_RESOURCE_INTERRUPT_LATCHED;
        PartialDesc->u.Interrupt.Vector = Com2Irq;
        PartialDesc->u.Interrupt.Level = Com2Irq;
        PartialDesc->u.Interrupt.Affinity = 0xFFFFFFFF;

        /* Return resources and success */
        *Resources = ResourceList;

        return STATUS_SUCCESS;
    }
    else if (DeviceExtension->PdoType == LpcKbdPdo)
    {
        PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialDesc;

        /* Allocate the resource list */
        ResourceList = ExAllocatePoolWithTag(PagedPool,
                                             sizeof(CM_RESOURCE_LIST) +
                                             2 * sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR),
                                             TAG_HAL_XBOX);
        if (!ResourceList)
        {
            /* Fail, no memory */
            Status = STATUS_INSUFFICIENT_RESOURCES;
            return Status;
        }

        /* Initialize it */
        RtlZeroMemory(ResourceList, sizeof(CM_RESOURCE_LIST));
        ResourceList->Count = 1;

        /* Setup the list fields */
        ResourceList->List[0].BusNumber = 0;
        ResourceList->List[0].InterfaceType = Isa;
        ResourceList->List[0].PartialResourceList.Version = 1;
        ResourceList->List[0].PartialResourceList.Revision = 1;
        ResourceList->List[0].PartialResourceList.Count = 3;

        PartialDesc = ResourceList->List[0].PartialResourceList.PartialDescriptors;
        PartialDesc->Type = CmResourceTypePort;
        PartialDesc->ShareDisposition = CmResourceShareDeviceExclusive;
        PartialDesc->Flags = CM_RESOURCE_PORT_IO;
        PartialDesc->u.Port.Start.LowPart = 0x60;
        PartialDesc->u.Port.Start.HighPart = 0;
        PartialDesc->u.Port.Length = 1;

        PartialDesc++;
        PartialDesc->Type = CmResourceTypePort;
        PartialDesc->ShareDisposition = CmResourceShareDeviceExclusive;
        PartialDesc->Flags = CM_RESOURCE_PORT_IO;
        PartialDesc->u.Port.Start.LowPart = 0x64;
        PartialDesc->u.Port.Start.HighPart = 0;
        PartialDesc->u.Port.Length = 1;

        PartialDesc++;
        PartialDesc->Type = CmResourceTypeInterrupt;
        PartialDesc->ShareDisposition = CmResourceShareUndetermined;
        PartialDesc->Flags = CM_RESOURCE_INTERRUPT_LATCHED;
        PartialDesc->u.Interrupt.Vector = KbdIrq;
        PartialDesc->u.Interrupt.Level = KbdIrq;
        PartialDesc->u.Interrupt.Affinity = 0xFFFFFFFF;

        /* Return resources and success */
        *Resources = ResourceList;

        return STATUS_SUCCESS;
    }
    else if (DeviceExtension->PdoType == LpcMouPdo)
    {
        PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialDesc;

        /* Allocate the resource list */
        ResourceList = ExAllocatePoolWithTag(PagedPool,
                                             sizeof(CM_RESOURCE_LIST),
                                             TAG_HAL_XBOX);
        if (!ResourceList)
        {
            /* Fail, no memory */
            Status = STATUS_INSUFFICIENT_RESOURCES;
            return Status;
        }

        /* Initialize it */
        RtlZeroMemory(ResourceList, sizeof(CM_RESOURCE_LIST));
        ResourceList->Count = 1;

        /* Setup the list fields */
        ResourceList->List[0].BusNumber = 0;
        ResourceList->List[0].InterfaceType = Isa;
        ResourceList->List[0].PartialResourceList.Version = 1;
        ResourceList->List[0].PartialResourceList.Revision = 1;
        ResourceList->List[0].PartialResourceList.Count = 1;

        PartialDesc = ResourceList->List[0].PartialResourceList.PartialDescriptors;
        PartialDesc->Type = CmResourceTypeInterrupt;
        PartialDesc->ShareDisposition = CmResourceShareUndetermined;
        PartialDesc->Flags = CM_RESOURCE_INTERRUPT_LATCHED;
        PartialDesc->u.Interrupt.Vector = MouIrq;
        PartialDesc->u.Interrupt.Level = MouIrq;
        PartialDesc->u.Interrupt.Affinity = 0xFFFFFFFF;

        /* Return resources and success */
        *Resources = ResourceList;

        return STATUS_SUCCESS;
    }
    else if (DeviceExtension->PdoType == LpcJoyPdo)
    {
        PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialDesc;

        /* Allocate the resource list */
        ResourceList = ExAllocatePoolWithTag(PagedPool,
                                             sizeof(CM_RESOURCE_LIST),
                                             TAG_HAL_XBOX);
        if (!ResourceList)
        {
            /* Fail, no memory */
            Status = STATUS_INSUFFICIENT_RESOURCES;
            return Status;
        }

        /* Initialize it */
        RtlZeroMemory(ResourceList, sizeof(CM_RESOURCE_LIST));
        ResourceList->Count = 1;

        /* Setup the list fields */
        ResourceList->List[0].BusNumber = 0;
        ResourceList->List[0].InterfaceType = Isa;
        ResourceList->List[0].PartialResourceList.Version = 1;
        ResourceList->List[0].PartialResourceList.Revision = 1;
        ResourceList->List[0].PartialResourceList.Count = 1;

        PartialDesc = ResourceList->List[0].PartialResourceList.PartialDescriptors;
        PartialDesc->Type = CmResourceTypePort;
        PartialDesc->ShareDisposition = CmResourceShareDeviceExclusive;
        PartialDesc->Flags = CM_RESOURCE_PORT_IO;
        PartialDesc->u.Port.Start.LowPart = JoyBase;
        PartialDesc->u.Port.Start.HighPart = 0;
        PartialDesc->u.Port.Length = 1;

        /* Return resources and success */
        *Resources = ResourceList;

        return STATUS_SUCCESS;
    }
    else if (DeviceExtension->PdoType == LpcMpuPdo)
    {
        PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialDesc;

        /* Allocate the resource list */
        ResourceList = ExAllocatePoolWithTag(PagedPool,
                                             sizeof(CM_RESOURCE_LIST) +
                                             sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR),
                                             TAG_HAL_XBOX);
        if (!ResourceList)
        {
            /* Fail, no memory */
            Status = STATUS_INSUFFICIENT_RESOURCES;
            return Status;
        }

        /* Initialize it */
        RtlZeroMemory(ResourceList, sizeof(CM_RESOURCE_LIST));
        ResourceList->Count = 1;

        /* Setup the list fields */
        ResourceList->List[0].BusNumber = 0;
        ResourceList->List[0].InterfaceType = Isa;
        ResourceList->List[0].PartialResourceList.Version = 1;
        ResourceList->List[0].PartialResourceList.Revision = 1;
        ResourceList->List[0].PartialResourceList.Count = 2;

        PartialDesc = ResourceList->List[0].PartialResourceList.PartialDescriptors;
        PartialDesc->Type = CmResourceTypePort;
        PartialDesc->ShareDisposition = CmResourceShareDeviceExclusive;
        PartialDesc->Flags = CM_RESOURCE_PORT_IO;
        PartialDesc->u.Port.Start.LowPart = MpuBase;
        PartialDesc->u.Port.Start.HighPart = 0;
        PartialDesc->u.Port.Length = 2;

        PartialDesc++;
        PartialDesc->Type = CmResourceTypeInterrupt;
        PartialDesc->ShareDisposition = CmResourceShareUndetermined;
        PartialDesc->Flags = CM_RESOURCE_INTERRUPT_LATCHED;
        PartialDesc->u.Interrupt.Vector = MpuIrq;
        PartialDesc->u.Interrupt.Level = MpuIrq;
        PartialDesc->u.Interrupt.Affinity = 0xFFFFFFFF;

        /* Return resources and success */
        *Resources = ResourceList;

        return STATUS_SUCCESS;
    }
    else
    {
        /* This shouldn't happen */
        return STATUS_UNSUCCESSFUL;
    }
}

NTSTATUS
NTAPI
HalpXboxQueryResourceRequirements(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PIO_RESOURCE_REQUIREMENTS_LIST *Requirements)
{
    PPDO_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;

    if (DeviceExtension->PdoType == CpuPdo)
    {
        return STATUS_SUCCESS;
    }
    else if (DeviceExtension->PdoType == PicPdo)
    {
        return STATUS_SUCCESS;
    }
    else if (DeviceExtension->PdoType == DmaPdo)
    {
        return STATUS_SUCCESS;
    }
    else if (DeviceExtension->PdoType == CmosPdo)
    {
        return STATUS_SUCCESS;
    }
    else if (DeviceExtension->PdoType == TimerPdo)
    {
        return STATUS_SUCCESS;
    }
    else if (DeviceExtension->PdoType == SpeakerPdo)
    {
        return STATUS_SUCCESS;
    }
    else if (DeviceExtension->PdoType == LpcPdo)
    {
        return STATUS_SUCCESS;
    }
    else if (DeviceExtension->PdoType == LpcFddPdo)
    {
        return STATUS_SUCCESS;
    }
    else if (DeviceExtension->PdoType == LpcParPdo)
    {
        return STATUS_SUCCESS;
    }
    else if (DeviceExtension->PdoType == LpcSer1Pdo)
    {
        return STATUS_SUCCESS;
    }
    else if (DeviceExtension->PdoType == LpcSer2Pdo)
    {
        return STATUS_SUCCESS;
    }
    else if (DeviceExtension->PdoType == LpcKbdPdo)
    {
        return STATUS_SUCCESS;
    }
    else if (DeviceExtension->PdoType == LpcMouPdo)
    {
        return STATUS_SUCCESS;
    }
    else if (DeviceExtension->PdoType == LpcJoyPdo)
    {
        return STATUS_SUCCESS;
    }
    else if (DeviceExtension->PdoType == LpcMpuPdo)
    {
        return STATUS_SUCCESS;
    }
    else
    {
        /* This shouldn't happen */
        return STATUS_UNSUCCESSFUL;
    }
}

NTSTATUS
NTAPI
HalpXboxQueryIdPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN BUS_QUERY_ID_TYPE IdType,
    IN OUT PWCHAR Id,
    IN OUT PULONG Length)
{
    /* Get the PDO type */
    PPDO_EXTENSION PdoExtension = DeviceObject->DeviceExtension;
    PDO_TYPE PdoType = PdoExtension->PdoType;
    PWCHAR CurrentId;
    WCHAR CpuId[100];

    switch (IdType)
    {
        case BusQueryDeviceID:
        case BusQueryHardwareIDs:
        {
            if (PdoType == CpuPdo)
            {
                PKPRCB Prcb = KeGetCurrentPrcb();

                swprintf(CpuId, L"ACPI\\%S_-_x86_Family_%d_Model_%d", Prcb->VendorString, Prcb->CpuType, Prcb->CpuStep >> 8);
                RtlCopyMemory(Id, CpuId, (wcslen(CpuId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL));
                *Length += (wcslen(CpuId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL);

                swprintf(CpuId, L"*%S_-_x86_Family_%d_Model_%d", Prcb->VendorString, Prcb->CpuType, Prcb->CpuStep >> 8);
                RtlCopyMemory(&Id[wcslen(Id) + 1], CpuId, (wcslen(CpuId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL));
                *Length += (wcslen(CpuId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL);

                swprintf(CpuId, L"ACPI\\%S_-_x86_Family_%d", Prcb->VendorString, Prcb->CpuType);
                RtlCopyMemory(&Id[wcslen(Id) + 1], CpuId, (wcslen(CpuId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL));
                *Length += (wcslen(CpuId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL);

                swprintf(CpuId, L"*%S_-_x86_Family_%d", Prcb->VendorString, Prcb->CpuType);
                RtlCopyMemory(&Id[wcslen(Id) + 1], CpuId, (wcslen(CpuId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL));
                *Length += (wcslen(CpuId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL);

                swprintf(CpuId, L"ACPI\\%S_-_x86", Prcb->VendorString);
                RtlCopyMemory(&Id[wcslen(Id) + 1], CpuId, (wcslen(CpuId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL));
                *Length += (wcslen(CpuId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL);

                swprintf(CpuId, L"*%S_-_x86", Prcb->VendorString);
                RtlCopyMemory(&Id[wcslen(Id) + 1], CpuId, (wcslen(CpuId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL));
                *Length += (wcslen(CpuId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL);

                return STATUS_SUCCESS;
            }

            else if (PdoType == PicPdo)
            {
                CurrentId = L"XBOX_HAL\\PNP0000";
                RtlCopyMemory(Id, CurrentId, (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL));
                *Length += (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL);

                CurrentId = L"*PNP0000";
                RtlCopyMemory(&Id[wcslen(Id) + 1], CurrentId, (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL));
                *Length += (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL);

                return STATUS_SUCCESS;
            }

            else if (PdoType == DmaPdo)
            {
                CurrentId = L"XBOX_HAL\\PNP0200";
                RtlCopyMemory(Id, CurrentId, (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL));
                *Length += (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL);

                CurrentId = L"*PNP0200";
                RtlCopyMemory(&Id[wcslen(Id) + 1], CurrentId, (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL));
                *Length += (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL);

                return STATUS_SUCCESS;
            }

            else if (PdoType == CmosPdo)
            {
                CurrentId = L"XBOX_HAL\\PNP0B00";
                RtlCopyMemory(Id, CurrentId, (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL));
                *Length += (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL);

                CurrentId = L"*PNP0B00";
                RtlCopyMemory(&Id[wcslen(Id) + 1], CurrentId, (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL));
                *Length += (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL);

                return STATUS_SUCCESS;
            }

            else if (PdoType == TimerPdo)
            {
                CurrentId = L"XBOX_HAL\\PNP0100";
                RtlCopyMemory(Id, CurrentId, (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL));
                *Length += (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL);

                CurrentId = L"*PNP0100";
                RtlCopyMemory(&Id[wcslen(Id) + 1], CurrentId, (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL));
                *Length += (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL);

                return STATUS_SUCCESS;
            }

            else if (PdoType == SpeakerPdo)
            {
                CurrentId = L"XBOX_HAL\\PNP0800";
                RtlCopyMemory(Id, CurrentId, (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL));
                *Length += (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL);

                CurrentId = L"*PNP0800";
                RtlCopyMemory(&Id[wcslen(Id) + 1], CurrentId, (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL));
                *Length += (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL);

                return STATUS_SUCCESS;
            }

            else if (PdoType == LpcPdo)
            {
                CurrentId = L"XBOX_HAL\\LpcSuperIO";
                RtlCopyMemory(Id, CurrentId, (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL));
                *Length += (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL);

                return STATUS_SUCCESS;
            }

            else if (PdoType == LpcFddPdo)
            {
                CurrentId = L"XBOX_HAL\\PNP0700";
                RtlCopyMemory(Id, CurrentId, (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL));
                *Length += (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL);

                CurrentId = L"*PNP0700";
                RtlCopyMemory(&Id[wcslen(Id) + 1], CurrentId, (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL));
                *Length += (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL);

                return STATUS_SUCCESS;
            }

            else if (PdoType == LpcParPdo)
            {
                CurrentId = L"XBOX_HAL\\PNP0400";
                RtlCopyMemory(Id, CurrentId, (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL));
                *Length += (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL);

                CurrentId = L"*PNP0400";
                RtlCopyMemory(&Id[wcslen(Id) + 1], CurrentId, (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL));
                *Length += (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL);

                return STATUS_SUCCESS;
            }

            else if (PdoType == LpcSer1Pdo)
            {
                CurrentId = L"XBOX_HAL\\PNP0501";
                RtlCopyMemory(Id, CurrentId, (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL));
                *Length += (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL);

                CurrentId = L"*PNP0501";
                RtlCopyMemory(&Id[wcslen(Id) + 1], CurrentId, (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL));
                *Length += (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL);

                return STATUS_SUCCESS;
            }

            else if (PdoType == LpcSer2Pdo)
            {
                CurrentId = L"XBOX_HAL\\PNP0501";
                RtlCopyMemory(Id, CurrentId, (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL));
                *Length += (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL);

                CurrentId = L"*PNP0501";
                RtlCopyMemory(&Id[wcslen(Id) + 1], CurrentId, (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL));
                *Length += (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL);

                return STATUS_SUCCESS;
            }

            else if (PdoType == LpcKbdPdo)
            {
                CurrentId = L"XBOX_HAL\\PNP0303";
                RtlCopyMemory(Id, CurrentId, (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL));
                *Length += (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL);

                CurrentId = L"*PNP0303";
                RtlCopyMemory(&Id[wcslen(Id) + 1], CurrentId, (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL));
                *Length += (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL);

                return STATUS_SUCCESS;
            }

            else if (PdoType == LpcMouPdo)
            {
                CurrentId = L"XBOX_HAL\\PNP0F13";
                RtlCopyMemory(Id, CurrentId, (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL));
                *Length += (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL);

                CurrentId = L"*PNP0F13";
                RtlCopyMemory(&Id[wcslen(Id) + 1], CurrentId, (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL));
                *Length += (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL);

                return STATUS_SUCCESS;
            }

            else if (PdoType == LpcJoyPdo)
            {
                CurrentId = L"XBOX_HAL\\PNPB02F";
                RtlCopyMemory(Id, CurrentId, (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL));
                *Length += (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL);

                CurrentId = L"*PNPB02F";
                RtlCopyMemory(&Id[wcslen(Id) + 1], CurrentId, (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL));
                *Length += (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL);

                return STATUS_SUCCESS;
            }

            else if (PdoType == LpcMpuPdo)
            {
                CurrentId = L"XBOX_HAL\\PNPB006";
                RtlCopyMemory(Id, CurrentId, (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL));
                *Length += (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL);

                CurrentId = L"*PNPB006";
                RtlCopyMemory(&Id[wcslen(Id) + 1], CurrentId, (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL));
                *Length += (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL);

                return STATUS_SUCCESS;
            }

            else
            {
                /* Unknown */
                return STATUS_NOT_SUPPORTED;
            }
        }

        case BusQueryInstanceID:
        {
            /* Instance ID */
            if (PdoType == CpuPdo)
                CurrentId = L"_0";
            else if (PdoType == LpcSer2Pdo)
                CurrentId = L"1";
            else
                CurrentId = L"0";
            RtlCopyMemory(Id, CurrentId, (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL));
            *Length += (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL);

            return STATUS_SUCCESS;
        }

        case BusQueryCompatibleIDs:
        {
            if (PdoType == CpuPdo)
            {
                CurrentId = L"ACPI\\Processor";
                RtlCopyMemory(Id, CurrentId, (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL));
                *Length += (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL);

                CurrentId = L"*Processor";
                RtlCopyMemory(&Id[wcslen(Id) + 1], CurrentId, (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL));
                *Length += (wcslen(CurrentId) * sizeof(WCHAR)) + sizeof(UNICODE_NULL);

                return STATUS_SUCCESS;
            }
            else
            {
                return STATUS_NOT_SUPPORTED;
            }
        }

        default:

            /* We don't support anything else */
            return STATUS_NOT_SUPPORTED;
    }
}

NTSTATUS
NTAPI
HalpXboxQueryDeviceTextPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp)
{
    PPDO_EXTENSION PdoExtension = DeviceObject->DeviceExtension;
    PDO_TYPE PdoType = PdoExtension->PdoType;
    PWCHAR CurrentText = NULL;
    UNICODE_STRING String;
    NTSTATUS Status = Irp->IoStatus.Status;

    switch (IrpSp->Parameters.QueryDeviceText.DeviceTextType)
    {
        case DeviceTextDescription:
            switch (PdoType)
            {
                case CpuPdo:
                    CurrentText = L"Central Processor";
                    break;

                case PicPdo:
                    CurrentText = L"PIC Controller";
                    break;

                case DmaPdo:
                    CurrentText = L"DMA Controller";
                    break;

                case CmosPdo:
                    CurrentText = L"CMOS/RTC Controller";
                    break;

                case TimerPdo:
                    CurrentText = L"Timer";
                    break;

                case SpeakerPdo:
                    CurrentText = L"Speaker";
                    break;

                case LpcPdo:
                    CurrentText = L"Super I/O Controller";
                    break;

                case LpcFddPdo:
                    CurrentText = L"Floppy Disk Controller";
                    break;

                case LpcParPdo:
                    CurrentText = L"LPT1 Port";
                    break;

                case LpcSer1Pdo:
                    CurrentText = L"COM1 Port";
                    break;

                case LpcSer2Pdo:
                    CurrentText = L"COM2 Port";
                    break;

                case LpcKbdPdo:
                    CurrentText = L"PS/2 Keyboard";
                    break;

                case LpcMouPdo:
                    CurrentText = L"PS/2 Mouse";
                    break;

                case LpcJoyPdo:
                    CurrentText = L"Game Port";
                    break;

                case LpcMpuPdo:
                    CurrentText = L"MPU-401 UART Port";
                    break;

                default:
                    break;
            }
            break;

        case DeviceTextLocationInformation:
            switch (PdoType)
            {
                case CpuPdo:
                    CurrentText = L"CPU Bridge";
                    break;

                case PicPdo:
                case DmaPdo:
                case CmosPdo:
                case TimerPdo:
                case SpeakerPdo:
                case LpcPdo:
                    CurrentText = L"LPC Bus";
                    break;

                case LpcFddPdo:
                case LpcParPdo:
                case LpcSer1Pdo:
                case LpcSer2Pdo:
                case LpcKbdPdo:
                case LpcMouPdo:
                case LpcJoyPdo:
                case LpcMpuPdo:
                    CurrentText = L"Super I/O Controller";
                    break;

                default:
                    break;
            }
            break;

        default:
            /* Inherit whatever status we had */
            break;
    }

    if (CurrentText)
    {
        Status = RtlCreateUnicodeString(&String, CurrentText) ? STATUS_SUCCESS : STATUS_INSUFFICIENT_RESOURCES;

        if (NT_SUCCESS(Status))
            Irp->IoStatus.Information = (ULONG_PTR)String.Buffer;
    }

    return Status;
}

/* EOF */
